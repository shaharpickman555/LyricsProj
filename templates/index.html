<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title><!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Song List</title>
  <!-- Socket.IO client library -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <!-- SortableJS for drag-and-drop -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    h1 {
      margin-bottom: 10px;
    }
    .controls {
      margin-bottom: 20px;
    }
    .song-input {
      font-size: 14px;
      padding: 5px;
    }
    .add-button {
      font-size: 14px;
      padding: 5px 10px;
      margin-left: 5px;
      cursor: pointer;
    }
    ul {
      list-style-type: none;
      padding-left: 0;
      max-width: 600px;
      transition: all 0.3s ease-in-out;
    }
    li {
      background-color: #f5f5f5;
      margin: 5px 0;
      padding: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-radius: 4px;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }
    li.removing {
      opacity: 0;
      transform: translateX(-100%);
    }
    li.adding {
      opacity: 0;
      transform: translateX(100%);
      animation: slideIn 0.25s forwards ease;
    }
    @keyframes slideIn {
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    .song-info {
      display: flex;
      align-items: center;
    }
    .song-title {
      font-weight: bold;
    }
    .song-icon {
      margin-left: 10px;
      font-size: 18px;
    }
    .now-playing-icon {
      margin-left: 10px;
      font-size: 18px;
      color: green;
    }
    .action-buttons {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .remove-btn {
      cursor: pointer;
      font-size: 16px;
      padding: 2px 5px;
      border: none;
      background-color: #eee;
      border-radius: 3px;
    }
    .remove-btn:hover {
      background-color: #ddd;
    }
    /* Drag handle (when song is draggable) */
    .drag-handle {
      cursor: move;
      font-size: 20px;
      color: #888;
      margin-right: 10px;
      user-select: none;
    }
    .drag-handle:hover {
      color: #555;
    }
  </style>
</head>
<body>
  <h1>Song List</h1>

  <div class="controls">
    <input type="text" id="song-title-input" class="song-input" placeholder="Enter new song title..." />
    <button id="add-song-btn" class="add-button">Add Song</button>
  </div>

  <ul id="song-list"></ul>

  <script>
  document.addEventListener("DOMContentLoaded", () => {
    const socket = io();
    const songListEl = document.getElementById('song-list');
    const addSongBtn = document.getElementById('add-song-btn');
    const songTitleInput = document.getElementById('song-title-input');

    // Listen for connect
    socket.on('connect', () => {
      console.log("Connected to Socket.IO server");
    });

    // Listen for the server's updated playlist
    socket.on('update_songs', (songs) => {
      console.log("Received updated playlist:", songs);
      reRenderSongList(songs);
    });

    // Initialize SortableJS
    const sortable = new Sortable(songListEl, {
      animation: 150,
      handle: ".drag-handle", // can only drag by handle
      onEnd: (evt) => {
        const oldIndex = evt.oldIndex;
        const newIndex = evt.newIndex;
        console.log(`Drag ended: from ${oldIndex} to ${newIndex}`);

        socket.emit('client_reorder', { oldIndex, newIndex });
      }
    });

    // Add Song
    addSongBtn.addEventListener('click', () => {
      const title = songTitleInput.value.trim();
      if (title) {
        socket.emit('client_add_song', { title: title });
        songTitleInput.value = '';
      }
    });

    /**
     * Re-render <ul> with transitions for adding/removing
     */
    function reRenderSongList(songs) {
      // Build a map of existing <li> elements by TID
      const existingElsByTid = {};
      [...songListEl.children].forEach(li => {
        existingElsByTid[li.dataset.tid] = li;
      });

      // Create new <li> elements in the correct order
      const newEls = songs.map((song) => {
        let li = existingElsByTid[song.tid];
        if (!li) {
          // This is a newly added song
          li = document.createElement('li');
          li.classList.add('adding');
          setTimeout(() => {
            li.classList.remove('adding');
          }, 250);
        }
        delete existingElsByTid[song.tid]; // mark as used

        // Store TID and is_playing
        li.dataset.tid = song.tid;
        li.dataset.isPlaying = song.is_playing;

        // Build the inside
        li.innerHTML = '';

        // Info div
        const infoDiv = document.createElement('div');
        infoDiv.classList.add('song-info');

        // If NOT playing => show drag handle
        if (!song.is_playing) {
          const dragHandle = document.createElement('span');
          dragHandle.classList.add('drag-handle');
          dragHandle.textContent = '⋮⋮'; // or any drag icon
          infoDiv.appendChild(dragHandle);
        }

        // Song title
        const titleSpan = document.createElement('span');
        titleSpan.classList.add('song-title');
        titleSpan.textContent = song.title;
        infoDiv.appendChild(titleSpan);

        // State icon
        const iconSpan = document.createElement('span');
        iconSpan.classList.add('song-icon');
        switch (song.state) {
          case 'queue':       iconSpan.textContent = '⏳'; break;
          case 'processing':  iconSpan.textContent = '🔄'; break;
          case 'done':        iconSpan.textContent = '✅'; break;
          case 'error':       iconSpan.textContent = '❌'; break;
          default:            iconSpan.textContent = '❓'; break;
        }
        infoDiv.appendChild(iconSpan);

        // Now playing?
        if (song.is_playing) {
          const npSpan = document.createElement('span');
          npSpan.classList.add('now-playing-icon');
          npSpan.textContent = '🔊';
          infoDiv.appendChild(npSpan);
        }

        // Action buttons
        const actionDiv = document.createElement('div');
        actionDiv.classList.add('action-buttons');

        // Remove button
        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.classList.add('remove-btn');
        removeBtn.addEventListener('click', () => {
          // Animate out, then emit
          li.classList.add('removing');
          setTimeout(() => {
            socket.emit('client_remove_song', { tid: song.tid });
          }, 200);
        });
        actionDiv.appendChild(removeBtn);

        // Append
        li.appendChild(infoDiv);
        li.appendChild(actionDiv);

        return li;
      });

      // Animate removal of leftover <li> (songs no longer in the new list)
      for (let tid in existingElsByTid) {
        const li = existingElsByTid[tid];
        li.classList.add('removing');
        setTimeout(() => {
          li.remove();
        }, 200);
      }

      // Rebuild the UL
      songListEl.innerHTML = '';
      newEls.forEach(li => {
        songListEl.appendChild(li);
      });

      // Let SortableJS know the new item order
      // The array must be a list of the "keys" (TIDs) in the final order
      sortable.sort(newEls.map(li => li.dataset.tid));
    }
  });
  </script>
</body>
</html>
</title>
</head>
<body>

</body>
</html>